package com.jjginga.searchtechnique;

import com.jjginga.result.SearchResult;
import com.jjginga.state.IState;

import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * Abstract class defining the structure and essential operations for search techniques.
 * It encapsulates common attributes such as the initial state, objective, execution time,
 * and mechanisms for asynchronous execution control like CountDownLatch.
 */
public abstract class AbstractSearchTechnique implements ISearchTechnique{

    //total time taken to perform the search in nanoseconds.
    protected long executionTime;
    //starting state
    private IState initialState;
    //objective the search aims to achive
    private int objective;

    //holds the result in case a solution isn't found
    protected SearchResult notFoundResult;
    //synchronization "tool" that allows that the main thread waits for the current state to be
    // captured before continuing, allowing that the number
    protected final CountDownLatch latch = new CountDownLatch(1);

    /**
     * Constructs an instance of a search technique with a specified initial state and objective.
     * @param initialState The initial state of the search.
     * @param objective The objective that the search aims to achieve.
     */
    public AbstractSearchTechnique(IState initialState, int objective) {
        this.initialState = initialState;
        this.objective = objective;
        this.executionTime = 0;
    }

    /**
     * Initiates the search operation. This method is meant to be called asynchronously,
     * wrapping the search process in a Callable for potential future execution.
     * @return A SearchResult that encapsulates the outcome of the search.
     */
    @Override
    public SearchResult call()  {
        return search(this.initialState, this.objective);
    }


    /**
     * Performs the search based on the provided initial state and objective. This is an abstract method
     * that must be implemented by subclasses to define the specific search algorithm.
     * @param initialState The state from which the search begins.
     * @param objective The goal the search aims to fulfill.
     * @return The result of the search operation as a SearchResult object.
     */
    protected abstract SearchResult performSearch(IState initialState, int objective);

    /**
     * Public interface to start the search. Measures the execution time of the search
     * and assigns it to the SearchResult before returning it.
     * @param initialState The initial state from where the search starts.
     * @param objective The search objective.
     * @return SearchResult object encapsulating the outcome of the search.
     */
    @Override
    public SearchResult search(IState initialState, int objective) {
        long startTime = System.nanoTime();
        SearchResult result = performSearch(initialState, objective);
        this.executionTime = System.nanoTime() - startTime;

        result.setExecutionTime(this.getExecutionTime());

        return result;
    }


    /**
     * Captures the current state of the search when it is interrupted or unable to find a solution.
     * This method updates the notFoundResult attribute with the latest state.
     * @param state The current state at the time of interruption.
     * @param generatedStates The number of states generated by the search up to the point of interruption.
     * @param depth The depth reached in the search space at the time of interruption.
     */
    protected void captureCurrentState(IState state, int generatedStates, int depth) {
        this.notFoundResult = new SearchResult(state, false, generatedStates, depth);
    }

    /**
     * Waits for the completion of operations in other threads signaled by counting down the latch.
     * This method is crucial for synchronizing the end of a search operation, especially in asynchronous execution.
     */
    public void awaitCompletion() {
        try {
            latch.await();//wait for the latch to be counted down
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();//preserve the interrupted status of the thread
        }
    }

    /**
     * Generates successors for a given state. This is a utility method that delegates to the IState's
     * method for generating successors, providing a common interface for all search techniques.
     * @param currentState The state for which to generate successors.
     * @return A list of successor states.
     */
    protected List<IState> generateSuccessors(IState currentState) {
        return currentState.generateSuccessors();

    }

    public long getExecutionTime() {
        return executionTime;
    }

    public SearchResult getNotFoundResult() {
        return notFoundResult;
    }

}
